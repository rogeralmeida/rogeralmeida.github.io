---
layout: post
title: "Tracing Bullet Pattern"
cover_picture: "/images/responsive/tracing-bullet.png"
comments: true
categories:
---

:markdown
  When starting a software project there are many uncertainties that need to be addressed:

  * Business Conditions
  * Technical Risks
  * Performance
  * _etc..._

  One critical component of a software architecture are the integration points between the many components. While your software is moving data in-memory it is operating in a controlled environment. But when you have to move this data between different components that you have a high chance of having problems.
  The tracing bullet is a delivery pattern that addresses this risk early on in a software delivery project.
  The idea comes from a bad source, from Wikipedia:

  > a ammunition built with a small pyrotechnic charge in their base. Ignited by the burning powder, the pyrotechnic composition burns very brightly, making the projectile trajectory visible to the naked eye during daylight, and very bright during nighttime firing. This enables the shooter to make aiming corrections without observing the impact of the rounds fired and without using the sights of the weapon. Tracer fire can also be used to signal to other shooters where to concentrate their fire during battle.

  The software delivery analogy is: "How we can send a message (not a bullet) through our new software so that we can inspect its behavior and correct course if needed."

%img{src: "/images/responsive/tracing-bullet.png"}
:markdown

  ## How to implement

  This is a simple patern to implement. Instead of implement all the layers in your new project, focus on the integration points. Suppose that you will implement the following design:

.mermaid
  :plain
    graph LR
      client[Client]
      rest[Rest API]
      queue[Queue]
      client-- 1. /post orders -->rest
      client-- 2. /put order/ID -->rest
      rest-- 3. dispatch order -->queue
:markdown
  This is a simplified version of a ordering system, where the first request will create a new order that will be persisted. The second request will update the order to mark as payed. This will also add the Order to a processing queue (to dispatch the order to the client)
  To create a tracing bullet for this system the minimal steps can be:
  * Implement a minimal entity with a ID and a STATE representation
  * Make one request to the service to create the new entity
  * Make a second request to the service to update the entity
  * Observe if the new entity was sent to the processing queue

  There is no logic to check stock, or prevent duplication, or dead letter, or price validation. the artefact can be as small as having only a single controller.
  The whole point of the Tracing Bullet is to be able to Observe the flow of the message.
  Ideally the tracing bullet should be fired in production environment. Although there is value in running the tracing bullet in UAT or pre-prod, the real value comes from know that it works where it should work (production environment)

:markdown
  ## When to use
  This pattern is very useful as the first milestone to a new project. It doesn't require a green field project. You can apply this pattern in an existing system.

  ## Caveats
  It is important to protect the production environment from side effects. You might have to implement some feature-toggles to prevent the tracing bullet from reaching areas/components that you don't want to test.
  The neighborhood might require some work to understand the tracing bullet as well.

  ## Conclusion
  The tracing bullet pattern can help you eliminate last mile problems earlier in your next software development project. It doesn't require much effort to implement it. Actually the hard part of implementing this pattern is to keep in mind that **less is more**.
  To apply this pattern to an existing software you will have to find ways to prevent the tracing bullet from having side effects.
